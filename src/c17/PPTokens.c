#include "PPTokens.h"

#include <assert.h>

#include "cli/diagnostic.h"

//=========== PRIVATE UTILITIES ================

/*
ascii_byte_lookup is a table to categorize each byte.
This look-up table has been generated by the following Python code:

s = ""
for i in range(128):
    c = chr(i)
    if c in " \r\t\v":
        s += " " # space
    elif c == "\n":
        s += "n" # newline
    elif "A" <= c <= "Z" or "a" <= c <= "z" or c == "_":
        s += "i" # identifier
    elif "0" <= c <= "9":
        s += "d" # decimal digit
    elif i < 32 or c in "$@`" or i == 127:
        s += "?" # unknown
    else:
        s += "p" # punctuator

for i in [ 0 , 32, 64, 96 ]:
    print('    "' + s[i:(i+32)] + '"')

*/
static char const ascii_byte_lookup[256]
    = "????????? n ? ??????????????????"
      " ppp?pppppppppppddddddddddpppppp"
      "?iiiiiiiiiiiiiiiiiiiiiiiiiippppi"
      "?iiiiiiiiiiiiiiiiiiiiiiiiiipppp?";
// values from indices 128-255 are initialized to '\0'

static StrView const hex_digits = STRVIEW_INIT("0123456789abcdefABCDEF");

static int checkIdentifier(StrView src) {
    assert(src.size >= 1);

    size_t i = 0;
    while (i < src.size) {
        unsigned char c = src.begin[i];
        char category = ascii_byte_lookup[c];
        if (category == 'i' || category == 'd' || c >= 128) {
            ++i;
            continue;
        }
        if (c == '\\' && i + 2 <= src.size) {
            // escape sequence, potentially universal character name
            char which_escape = src.begin[i + 1];
            if (which_escape == 'u' || which_escape == 'U') {
                // \uABCD or \U01234567, expects 4 or 8 hex-digits
                size_t nb_digits = (which_escape == 'U' ? 8 : 4);

                if (i + 2 + nb_digits > src.size)
                    return -1;  // incomplete universal character name =>
                                // incomplete token

                StrView expecting_hexa = {src.begin + i + 2, nb_digits};
                if (jvstr_while_in(expecting_hexa, hex_digits, 0)
                    == nb_digits) {
                    i += 2 + nb_digits;
                    continue;
                }
            }
            // other escape code, which is not part of identifier.
            break;
        }
        // neither identifier char nor escape sequence: identifier is finished
        break;
    }
    return (int)i;
}

static size_t findCharStrLiteralStart(StrView src, StrView list_prefixes,
                                      StrView then) {
    // First check for prefix
    StrView prefix = {0};  // first checking with empty prefix
    while (true) {
        // checking if we have prefix + then ( 'then' may be ', " or R" )
        if (src.size >= prefix.size + then.size
            && jvstr_starts_with(src, then, prefix.size)
            && jvstr_starts_with(src, prefix, 0))
            return prefix.size + then.size;  // found

        if (list_prefixes.size == 0) return 0;

        prefix = jvstr_split(&list_prefixes, jvstr_find(list_prefixes, ' '), 1);
    }
}

static size_t findAnyUnescaped(StrView src, StrView charset, size_t pos) {
    while (true) {
        pos = jvstr_until_in(src, charset, pos);
        if (pos == src.size) {
            return src.size;
        }
        if (src.begin[pos - 1] == '\\') {
            // escaped char of charset
            ++pos;  // skip current char escaped
            continue;
        }
        return pos;
    }
}

//=========== CHECK FOR EACH TOKEN KIND ================

static int check_HEADER_NAME(StrView src) {
    assert(src.size >= 1);

    char first_char = src.begin[0];

    if (first_char == '<') {
        size_t end = jvstr_until_in(src, STRVIEW_MAKE(">\n"), 1);
        if (end == src.size || src.begin[end] == '\n')
            return -1;
        else
            return (int)(end + 1);  // including '>'
    } else if (first_char == '"') {
        size_t end = jvstr_until_in(src, STRVIEW_MAKE("\"\n"), 1);
        if (end == src.size || src.begin[end] == '\n')
            return -1;
        else
            return (int)(end + 1);  // including '"'
    }
    return 0;
}

static int check_IDENTIFIER(StrView src) {
    assert(src.size >= 1);

    if (ascii_byte_lookup[(unsigned char)src.begin[0]] == 'd')
        return 0;  // if it starts with a decimal digit, then it is a number.

    return checkIdentifier(src);
}

static int check_NUMBER(StrView src) {
    assert(src.size >= 1);

    // if does not start by '\d' or '.\d', it is not a number.
    if (ascii_byte_lookup[(unsigned char)src.begin[0]] != 'd')
        if (src.size <= 1 || src.begin[0] != '.'
            || ascii_byte_lookup[(unsigned char)src.begin[1]] != 'd')
            return 0;

    size_t i = 1;  // we already checked for the first character
    while (i < src.size) {
        // preprocessing-number is a superset of identifier.
        int identifier
            = checkIdentifier((StrView){src.begin + i, src.size - i});
        if (identifier > 0) {
            i += identifier;
            continue;
        } else if (identifier < 0) {
            return identifier;
        }
        char c = src.begin[i];
        if (c == '.') {
            ++i;
            continue;
        }
        if (c == '+' || c == '-') {
            char c_prev = src.begin[i - 1];  // safe, i >= 1
            if (strchr("pPeE", c_prev) == NULL) {
                break;  // NOT 'p+' or 'e-'
            } else {
                ++i;
                continue;
            }
        }
        break;
    }
    return (int)i;
}

static int check_CHAR_LITERAL(StrView src) {
    assert(src.size >= 1);

    // Find prefix (possibly empty)
    size_t i = findCharStrLiteralStart(src, STRVIEW_MAKE("L u U"),
                                       STRVIEW_MAKE("'"));
    if (i == 0) return 0;

    i = findAnyUnescaped(src, STRVIEW_MAKE("'\n"), i);
    if (i == src.size) return -1;
    if (src.begin[i] == '\n') return -1;
    // found closing '
    return i + 1;
}

static int check_STRING_LITERAL(StrView src) {
    assert(src.size >= 1);

    // Find prefix (possibly empty)
    size_t i = findCharStrLiteralStart(src, STRVIEW_MAKE("u8 u U L"),
                                       STRVIEW_MAKE("\""));
    if (i == 0) return 0;

    i = findAnyUnescaped(src, STRVIEW_MAKE("\"\n"), i);
    if (i == src.size) return -1;
    if (src.begin[i] == '\n') return -1;
    // found closing '
    return i + 1;
}

static StrView const c17_punctuators = STRVIEW_INIT(
    "*= /= %= += -= <<= >>= &= ^= |= "
    "%:%: %: <: :> <% %> "
    "## # , ... ; : ? [ ] ( ) { } . -> "
    "<= >= == != && || ! << >> < > "
    "++ -- & | ^ ~ + - * / % =");

static int check_PUNCTUATOR(StrView src) {
    assert(src.size >= 1);

    StrView punctuators = c17_punctuators;
    while (punctuators.size > 0) {
        StrView punctuator
            = jvstr_split(&punctuators, jvstr_find(punctuators, ' '), 1);
        if (jvstr_starts_with(src, punctuator, 0)) return punctuator.size;
    }
    return 0;
}

static int check_WHITESPACE(StrView src) {
    assert(src.size >= 1);

    size_t i = 0;
    while (true) {
        i = jvstr_while_in(src, STRVIEW_MAKE(" \r\t\v"), i);
        if (jvstr_starts_with(src, STRVIEW_MAKE("\\\n"),
                              i)) {  // escaped newlines are OK
            i += 2;
            continue;
        }
        break;
    }
    return i;
}

static int check_COMMENT(StrView src) {
    assert(src.size >= 1);

    if (jvstr_starts_with(src, STRVIEW_MAKE("/*"), 0)) {
        // multi-line comment
        size_t end = 2
                     + jvstr_search((StrView){src.begin + 2, src.size - 2},
                                    STRVIEW_MAKE("*/"));
        return (end == src.size)
                   ? -1
                   : (int)end + 2;  // "*/" is part of the comment too
    } else if (jvstr_starts_with(src, STRVIEW_MAKE("//"), 0)) {
        // single-line comment
        size_t end = jvstr_find_unescaped(src, '\n', '\\');
        return (end == src.size) ? -1
                                 : (int)end;  // '\n' is not part of the comment
    } else {
        return 0;
    }
}

static int check_NEWLINE(StrView src) {
    assert(src.size >= 1);

    return src.begin[0] == '\n' ? 1 : 0;
}

//=========== PUBLIC FUNCTIONS ================

// High-level function to transform a logical line of source file to a list of
// PPToken. The sequence of PPToken is appended to 'out'.
// EMIT AN ERROR if a token is incomplete (header-name, string constant, etc).
// EMIT A WARNING if a line is incomplete (not ending by '\n').
size_t PPtokenizeLogicalLine(StrView str, DynArray* out) {
    if (str.size == 0) return 0;

    enum {
        STATE_NEWLINE,
        STATE_PPDIRECTIVE,
        STATE_HEADERNAME_EXPECTED,
        STATE_NONE,
    } state
        = STATE_NEWLINE;

    int nb_tokens = 0;

    PPToken token = {0};
    int token_size;
    // clang-format off
#define CASE(tokenkind)                    \
do {                                       \
    token_size = check_##tokenkind(str);   \
    if (token_size != 0) {                 \
        token.kind = PPToken_##tokenkind;  \
        goto found_token_kind;             \
    }                                      \
} while (0)
    // clang-format on

    do {
        // special case for header names because they can only be detected in
        // some places.
        if (state == STATE_HEADERNAME_EXPECTED) CASE(HEADER_NAME);

        // The order in which we will try the kinds of tokens is important! For
        // instance:
        // - NUMBER must be before PUNCTUATOR, because '.5' will be found as
        // PUNCTUATOR with '.'
        // - COMMENT must be before PUNCTUATOR, because '/' + '*' will be an
        // PUNCTUATOR with '/'
        // - CHAR_LITERAL before IDENTIFIER, because "u8'_'" will be an
        // IDENTIFIER with "u8"
        // - UNKNOWN_BYTE will match anything, so it must be at the end.
        CASE(CHAR_LITERAL);
        CASE(STRING_LITERAL);
        CASE(COMMENT);
        CASE(NEWLINE);
        CASE(WHITESPACE);
        CASE(NUMBER);
        CASE(IDENTIFIER);
        CASE(PUNCTUATOR);

        // could not find any identifier:
        // append NEWLINE to start fresh, and emit error.
        token.kind = PPToken_NEWLINE;
        token.repr = STRVIEW_MAKE("\n");
        DynArray_pushback(out, &token, sizeof(token));
        emitError("Could not tokenize \"%.*s\".", (int)str.size - 1,
                  str.begin);  // not including newline

    found_token_kind:
        if (token_size < 0) {
            // incomplete token
            token.kind = PPToken_NEWLINE;
            token.repr = STRVIEW_MAKE("\n");
            DynArray_pushback(out, &token, sizeof(token));
            emitError(
                "Incomplete token: %.*s\n"
                "Did you forget a closing quote?\n",
                (int)str.size - 1, str.begin);
        }
        token.repr = jvstr_split(&str, token_size, 0);
        DynArray_pushback(out, &token, sizeof(token));
        ++nb_tokens;

        // updating state:
        if (token.kind == PPToken_COMMENT || token.kind == PPToken_WHITESPACE)
            continue;  // no state update

        if (state == STATE_NEWLINE && token.kind == PPToken_PUNCTUATOR
            && jvstr_equal(token.repr, STRVIEW_MAKE("#"))) {
            state = STATE_PPDIRECTIVE;
        } else if (state == STATE_PPDIRECTIVE
                   && token.kind == PPToken_IDENTIFIER
                   && jvstr_equal(token.repr, STRVIEW_MAKE("include"))) {
            state = STATE_HEADERNAME_EXPECTED;
        } else if (token.kind == PPToken_NEWLINE) {
            state = STATE_NEWLINE;
        } else {
            state = STATE_NONE;
        }

    } while (str.size > 0);
    // at this point, we are sure to have emitted at least one token.
    if (((PPToken*)out->end)[-1].kind != PPToken_NEWLINE) {
        // if last token generated was not NEWLINE
        emitWarning(
            "Line not ending by the NEWLINE character.\n"
            "According to ISO C17, it is undefined behaviour.\n"
            "To fix this warning, make sure your file ends with an empty "
            "line.\n");
    }
    return nb_tokens;
#undef CASE
}

int checkPPToken(StrView src, PPTokenKind kind) {
    // clang-format off
#define CASE(kind) case PPToken_##kind: return check_##kind(src);
    // clang-format on
    assert(src.size >= 1);

    switch (kind) {  // will emit a warning in case of forgotten case
        CASE(HEADER_NAME);
        CASE(IDENTIFIER);
        CASE(NUMBER);
        CASE(CHAR_LITERAL);
        CASE(STRING_LITERAL);
        CASE(PUNCTUATOR);
        CASE(WHITESPACE);
        CASE(COMMENT);
        CASE(NEWLINE);
    }
    return 0;
#undef CASE
}

PPTokenKind ppTokenKindFromName(char const* name) {
    // clang-format off
#define CASE(kind) if (strcmp(name, #kind) == 0) return PPToken_##kind;
    // clang-format on

    CASE(HEADER_NAME);
    CASE(IDENTIFIER);
    CASE(NUMBER);
    CASE(CHAR_LITERAL);
    CASE(STRING_LITERAL);
    CASE(PUNCTUATOR);
    CASE(WHITESPACE);
    CASE(COMMENT);
    CASE(NEWLINE);
    return PPToken_WHITESPACE;
#undef CASE
}

char const* nameFromPPTokenKind(PPTokenKind kind) {
    // clang-format off
#define CASE(kind) case PPToken_##kind: return #kind
    // clang-format on

    switch (kind) {  // will emit a warning in case of forgotten case
        CASE(HEADER_NAME);
        CASE(IDENTIFIER);
        CASE(NUMBER);
        CASE(CHAR_LITERAL);
        CASE(STRING_LITERAL);
        CASE(PUNCTUATOR);
        CASE(WHITESPACE);
        CASE(COMMENT);
        CASE(NEWLINE);
    }
    return "???";
#undef CASE
}